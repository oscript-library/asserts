#Использовать "../internal"

Перем ПроверяемоеЗначение;           // Установленное проверяемое значение
Перем ИмяМетода;                     // Имя проверяемого метода
Перем ПараметрыМетода;               // Параметры проверяемого метода
Перем ДопСообщениеОшибки;            // Пользовательское сообщение ошибки
Перем ФлагОтрицания;                 // Нужно инвертировать результат проверки
Перем ФлагОтрицанияДляСообщения;     // Значение флага отрицания для вывода пользователю
Перем ПараметрыСравненияТаблиц;      // Настройки сравнения таблиц
Перем ПараметрыСравненияМассивов;    // Настройки сравнения массивов

Функция Что(Знач ПроверяемоеЗначениеПараметр, Знач Сообщение = "") Экспорт
	ПроверяемоеЗначение = ПроверяемоеЗначениеПараметр;
	ДопСообщениеОшибки = Сообщение;
	ФлагОтрицания = Ложь;
	ФлагОтрицанияДляСообщения = Ложь;

	Возврат ЭтотОбъект;
КонецФункции

Процедура ПриСозданииОбъекта(Знач ПроверяемоеЗначениеПараметр, Знач Сообщение = "")
	ПроверяемоеЗначение = ПроверяемоеЗначениеПараметр;
	ДопСообщениеОшибки = Сообщение;
	ФлагОтрицания = Ложь;
	ФлагОтрицанияДляСообщения = Ложь;

	ПараметрыСравненияТаблиц = Новый Структура;
	ПараметрыСравненияТаблиц.Вставить("УчитыватьПорядокСтрок", Истина);
	ПараметрыСравненияТаблиц.Вставить("УчитыватьПорядокКолонок", Истина);
	ПараметрыСравненияТаблиц.Вставить("УчитыватьИменаКолонок", Истина);
	
	ПараметрыСравненияМассивов = Новый Структура;
	ПараметрыСравненияМассивов.Вставить("УчитыватьПорядокЗначений", Истина);
КонецПроцедуры

Функция Не_() Экспорт
	ФлагОтрицания = Истина;

	Возврат ЭтотОбъект;
КонецФункции

Функция ЭтоНе() Экспорт
	Возврат Не_();
КонецФункции

Функция Метод(Знач ИмяМетодаПараметр, Знач ПараметрыМетодаПараметр = Неопределено) Экспорт
	ИмяМетода = ИмяМетодаПараметр;
	Если ПараметрыМетодаПараметр = Неопределено Тогда
		ПараметрыМетода = Новый Массив;
	Иначе
		ПараметрыМетода = ПараметрыМетодаПараметр;
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция ЭтоИстина() Экспорт
	Если Не ЛогическоеВыражениеВерно(ПроверяемоеЗначение = Истина) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПредставлениеЗначения(), "является ИСТИНОЙ.");
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция ЕстьИстина() Экспорт
	Возврат ЭтоИстина();
КонецФункции

Функция ЭтоЛожь() Экспорт
	Если Не ЛогическоеВыражениеВерно(ПроверяемоеЗначение = Ложь) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПредставлениеЗначения(), "является ЛОЖЬЮ.");
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция ЕстьЛожь() Экспорт
	Возврат ЭтоЛожь();
КонецФункции

Функция Равно(Знач ОжидаемоеЗначение) Экспорт
	Если Не ЛогическоеВыражениеВерно(ПроверяемоеЗначение = ОжидаемоеЗначение) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПроверяемоеЗначение, "РАВНО (" + ОжидаемоеЗначение + ").");
		Если ТипЗнч(ПроверяемоеЗначение) <> ТипЗнч(ОжидаемоеЗначение) Тогда
			СообщениеОшибки = СтрШаблон(
				"%1
				|Тип проверяемого значения (%2) НЕ РАВЕН  типу ожидаемого значения (%3).",
				СообщениеОшибки,
				ТипЗнч(ПроверяемоеЗначение),
				ТипЗнч(ОжидаемоеЗначение)
			);
		КонецЕсли;
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция Больше(Знач МеньшееЗначение) Экспорт
	Если Не ЛогическоеВыражениеВерно(ПроверяемоеЗначение > МеньшееЗначение) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПроверяемоеЗначение, "БОЛЬШЕ (" + МеньшееЗначение + ").");
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция БольшеИлиРавно(Знач МеньшееИлиРавноеЗначение) Экспорт
	Если Не ЛогическоеВыражениеВерно(ПроверяемоеЗначение >= МеньшееИлиРавноеЗначение) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(
			ПроверяемоеЗначение,
			СтрШаблон("БОЛЬШЕ ИЛИ РАВНО (%1).", МеньшееИлиРавноеЗначение)
		);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция Минимум(Знач МинимальноеЗначение) Экспорт
	Возврат БольшеИлиРавно(МинимальноеЗначение);
КонецФункции

Функция МеньшеИлиРавно(Знач БольшееИлиРавноеЗначение) Экспорт
	Если Не ЛогическоеВыражениеВерно(ПроверяемоеЗначение <= БольшееИлиРавноеЗначение) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(
			ПроверяемоеЗначение,
			СтрШаблон("МЕНЬШЕ ИЛИ РАВНО (%1).", БольшееИлиРавноеЗначение)
		);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция Максимум(Знач МаксимальноеЗначение) Экспорт
	Возврат МеньшеИлиРавно(МаксимальноеЗначение);
КонецФункции

Функция Меньше(Знач БольшееЗначение) Экспорт
	Если Не ЛогическоеВыражениеВерно(ПроверяемоеЗначение < БольшееЗначение) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПроверяемоеЗначение, "МЕНЬШЕ (" + БольшееЗначение + ").");
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция Заполнено() Экспорт
	Если Не ЛогическоеВыражениеВерно(ЗначениеЗаполнено(ПроверяемоеЗначение)) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПроверяемоеЗначение, "является ЗАПОЛНЕННЫМ.");
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция Существует() Экспорт
	Если Не ЛогическоеВыражениеВерно(ПроверяемоеЗначение <> Неопределено И ПроверяемоеЗначение <> Null) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПроверяемоеЗначение, "СУЩЕСТВУЕТ.");
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция ЭтоНеопределено() Экспорт
	Если Не ЛогическоеВыражениеВерно(ПроверяемоеЗначение = Неопределено) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПроверяемоеЗначение, "является НЕОПРЕДЕЛЕНО.");
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция ЕстьНеопределено() Экспорт
	Возврат ЭтоНеопределено();
КонецФункции

Функция ЭтоNull() Экспорт
	Если Не ЛогическоеВыражениеВерно(ПроверяемоеЗначение = Null) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПроверяемоеЗначение, "является NULL.");
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция ЕстьNull() Экспорт
	Возврат ЭтоNull();
КонецФункции

Функция ИмеетТип(Знач ТипИлиИмяТипа) Экспорт
	ОжидаемыйТип = ?(ТипЗнч(ТипИлиИмяТипа) = Тип("Строка"), Тип(ТипИлиИмяТипа), ТипИлиИмяТипа);
	ТипПроверяемогоЗначения = ТипЗнч(ПроверяемоеЗначение);
	Если Не ЛогическоеВыражениеВерно(ТипПроверяемогоЗначения = ОжидаемыйТип) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(
			СтрШаблон("тип - %1", ТипПроверяемогоЗначения),
			СтрШаблон("имеет тип (%1).", ОжидаемыйТип)
		);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция Между(Знач НачальноеЗначение, Знач КонечноеЗначение) Экспорт
	Если Не ЛогическоеВыражениеВерно(
		ПроверяемоеЗначение >= НачальноеЗначение И ПроверяемоеЗначение <= КонечноеЗначение) Тогда

		СообщениеОшибки = СформироватьСообщениеОбОшибке(
			ПроверяемоеЗначение,
			СтрШаблон("МЕЖДУ (%1) и (%2).", НачальноеЗначение, КонечноеЗначение)
		);
		ВызватьОшибкуПроверки(СообщениеОшибки);

	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция Содержит(Знач ИскомоеЗначение) Экспорт

	ТипПроверяемогоЗначения = ТипЗнч(ПроверяемоеЗначение);

	Если ТипПроверяемогоЗначения = Тип("Строка") Тогда
		ИскомоеЗначениеНайдено = СодержитСтроку(ПроверяемоеЗначение, ИскомоеЗначение);
	ИначеЕсли ТипПроверяемогоЗначения = Тип("Массив") Тогда
		ИскомоеЗначениеНайдено = ПроверяемоеЗначение.Найти(ИскомоеЗначение) <> Неопределено;
	ИначеЕсли ТипПроверяемогоЗначения = Тип("Структура")
			Или ТипПроверяемогоЗначения = Тип("Соответствие") Тогда

		Для каждого КлючЗначение Из ПроверяемоеЗначение Цикл
			ИскомоеЗначениеНайдено = КлючЗначение.Значение = ИскомоеЗначение;
			Если ИскомоеЗначениеНайдено Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;

	ИначеЕсли ТипПроверяемогоЗначения = Тип("СписокЗначений") Тогда
		ИскомоеЗначениеНайдено = ПроверяемоеЗначение.НайтиПоЗначению(ИскомоеЗначение) <> Неопределено;
	ИначеЕсли ЭтоЧитаемаяКоллекция(ТипПроверяемогоЗначения) Тогда
		ИскомоеЗначениеНайдено = ПроверяемоеЗначение.Содержит(ИскомоеЗначение);
	ИначеЕсли ЭтоЧитаемаяКарта(ТипПроверяемогоЗначения) Тогда
		ИскомоеЗначениеНайдено = ПроверяемоеЗначение.СодержитЗначение(ИскомоеЗначение);
	Иначе

		ВызватьИсключение СтрШаблон(
			"Утверждение ""Содержит"" не умеет работать с типом <%1>, %2",
			ТипПроверяемогоЗначения,
			ФорматДСО(ДопСообщениеОшибки)
		);

	КонецЕсли;

	Если Не ЛогическоеВыражениеВерно(ИскомоеЗначениеНайдено) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПроверяемоеЗначение, "СОДЕРЖИТ (" + ИскомоеЗначение + ").");
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция ИмеетДлину(Знач ОжидаемаяДлина) Экспорт
	Перем ФактическаяДлина;

	ТипПроверяемогоЗначения = ТипЗнч(ПроверяемоеЗначение);
	Если ТипПроверяемогоЗначения = Тип("Строка") Тогда
		ФактическаяДлина = СтрДлина(ПроверяемоеЗначение);
	Иначе
		Попытка
			ФактическаяДлина = ПроверяемоеЗначение.Количество();
		Исключение
			ФактическаяДлина = Неопределено;
		КонецПопытки;
	КонецЕсли;

	Если ФактическаяДлина = Неопределено Тогда
		СообщениеОшибки = СтрШаблон(
			"Утверждение ""ИмеетДлину"" не умеет работать с типом <%1>. %2",
			ТипПроверяемогоЗначения,
			ФорматДСО(ДопСообщениеОшибки)
		);
		ВызватьИсключение СообщениеОшибки;
	КонецЕсли;

	Если Не ЛогическоеВыражениеВерно(ФактическаяДлина = ОжидаемаяДлина) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(
			СтрШаблон("<%1> с длиной %2", ПроверяемоеЗначение, ФактическаяДлина),
			СтрШаблон("ИМЕЕТ ДЛИНУ (%1).", ОжидаемаяДлина)
		);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция ВыбрасываетИсключение(Знач ФрагментИсключения = "") Экспорт
	Контекст = ПроверяемоеЗначение;
	ИсключениеВозникло = Ложь;

	Попытка
		Рефлектор = Новый Рефлектор;
		Рефлектор.ВызватьМетод(Контекст, ИмяМетода, ПараметрыМетода);
	Исключение
		ИсключениеВозникло = Истина;
		ТекстИсключения = ОписаниеОшибки();
		ИнформацияОбОшибке = ИнформацияОбОшибке();
	КонецПопытки;

	Если Не ЛогическоеВыражениеВерно(ИсключениеВозникло И СтрНайти(ТекстИсключения, ФрагментИсключения) > 0) Тогда

		СообщениеОшибки = Новый СтрШаблон(
			"Ожидали, что %1 %2 ВЫБРОСИТ ИСКЛЮЧЕНИЕ %3",
			ИмяМетода,
			?(ФлагОтрицанияДляСообщения, "НЕ", ""),
			?(ЗначениеЗаполнено(ФрагментИсключения),
				СтрШаблон("СОДЕРЖАЩЕЕ ТЕКСТ <%1>, а был текст <%2>.", ФрагментИсключения, ТекстИсключения),
				ТекстИсключения
			)
		);

		ВызватьОшибкуПроверки(СообщениеОшибки, ИнформацияОбОшибке);

	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

// Проверяет существование метода с указанным именем
// 
// Выбрасывает исключение, если метод отсутствует
//
// Параметры:
//  ИмяМетода  - Строка - Имя метода, наличие которого требуется проверить
//
// Возвращаемое значение:
//  БДДАссерт - Текущий объект
//
Функция ИмеетМетод(Знач ИмяМетода) Экспорт
	Перем Рефлектор;

	Рефлектор = Новый Рефлектор;
	Если НЕ ЛогическоеВыражениеВерно(Рефлектор.МетодСуществует(ПроверяемоеЗначение, ИмяМетода)) Тогда
		ВызватьОшибкуПроверки("Ожидали что объект имеет метод с именем '" + ИмяМетода + "'" + ФорматДСО(ДопСообщениеОшибки));
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция РавнаТаблице(Знач ОжидаемоеЗначение, Знач СравнитьТолькоСТруктуру = Ложь) Экспорт

	Различия = РазличияТаблиц(ПроверяемоеЗначение, ОжидаемоеЗначение, СравнитьТолькоСТруктуру);


	ВсеОК = Различия.Количество() = 0;
	ВсеОК = ?(ФлагОтрицания, Не ВсеОК, ВсеОК);
	
	ФлагОтрицанияДляСообщения = ФлагОтрицания;
	ФлагОтрицания = Ложь;

	Если Не ВсеОК Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПроверяемоеЗначение, "РАВНО (" + ОжидаемоеЗначение + ").
		|Различия таблиц:");

		Для Каждого Различие Из Различия Цикл
			СообщениеОшибки = СтрШаблон("%1%2[%3:%4]: ожидали <%5>, а получили <%6>", СообщениеОшибки, Символы.ПС,
												Различие.Строка, Различие.Колонка, Различие.Ожидание, Различие.Результат);
		КонецЦикла;
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция ИмеетРавнуюСтруктуруСТаблицей(Знач ОжидаемоеЗначение) Экспорт
	Возврат РавнаТаблице(ОжидаемоеЗначение, Истина);
КонецФункции

Функция СодержитСтрокуТаблицы(Знач ОжидаемоеЗначение) Экспорт

	СтруктураПоиска = Новый Структура(СтрСоединить(ИменаКолонок(ПроверяемоеЗначение), ","));
	ЗаполнитьЗначенияСвойств(СтруктураПоиска, ОжидаемоеЗначение);

	НайденныеСтроки = ПроверяемоеЗначение.НайтиСтроки(СтруктураПоиска);

	ВсеОК = НайденныеСтроки.Количество() = 1;
	ВсеОК = ?(ФлагОтрицания, Не ВсеОК, ВсеОК);

	ФлагОтрицанияДляСообщения = ФлагОтрицания;
	ФлагОтрицания = Ложь;

	Если Не ВсеОК Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПроверяемоеЗначение, "СОДЕРЖИТ нужную строку.");
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция БезУчетаПорядкаСтрок() Экспорт
	ПараметрыСравненияТаблиц.Вставить("УчитыватьПорядокСтрок", Ложь);

	Возврат ЭтотОбъект;
КонецФункции

Функция БезУчетаПорядкаКолонок() Экспорт
	ПараметрыСравненияТаблиц.Вставить("УчитыватьПорядокКолонок", Ложь);

	Возврат ЭтотОбъект;
КонецФункции

Функция БезУчетаИменКолонок() Экспорт
	ПараметрыСравненияТаблиц.Вставить("УчитыватьИменаКолонок", Ложь);

	Возврат ЭтотОбъект;
КонецФункции

Функция НеУчитыватьПорядокВМассиве() Экспорт
	ПараметрыСравненияМассивов.Вставить("УчитыватьПорядокЗначений", Ложь);

	Возврат ЭтотОбъект;
КонецФункции

Функция Идентично(Знач ОжидаемоеЗначение) Экспорт

	ТипОжидаемогоЗначения = ТипЗнч(ОжидаемоеЗначение);

	Флаги = СохранитьФлаги();
	ИмеетТип(ТипОжидаемогоЗначения);
	ВосстановитьФлаги(Флаги);

	// Направляем в соответствующие методы в зависимости от типа
	Если ТипОжидаемогоЗначения = Тип("ТаблицаЗначений") Тогда
		РавнаТаблице(ОжидаемоеЗначение, Ложь);
	ИначеЕсли ТипОжидаемогоЗначения = Тип("Массив") Тогда
		РавноМассиву(ОжидаемоеЗначение);
	ИначеЕсли ТипОжидаемогоЗначения = Тип("Структура")
			Или ТипОжидаемогоЗначения = Тип("Соответствие") Тогда
		РавноСтруктуреИлиСоответствию(ОжидаемоеЗначение);
	Иначе
		// Для прочих типов используем обычное сравнение
		Равно(ОжидаемоеЗначение);
	КонецЕсли;

	Возврат ЭтотОбъект;
КонецФункции

Функция РавноМассиву(Знач ОжидаемоеЗначение) Экспорт
	
	Если Не ТипЗнч(ОжидаемоеЗначение) = Тип("Массив") Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ОжидаемоеЗначение, "ИМЕЕТ ТИП <Массив>.");
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
	
	// Используем функцию с детализацией
	РезультатСравнения = МассивыИдентичныСДетализацией(ПроверяемоеЗначение, ОжидаемоеЗначение, "");
	Если Не ЛогическоеВыражениеВерно(РезультатСравнения.Идентичны) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПроверяемоеЗначение, СтрШаблон("РАВНО массиву (%1)%2%3", 
			ОжидаемоеЗначение, Символы.ПС, РезультатСравнения.ОписаниеОшибки));
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
	
	Возврат ЭтотОбъект;
КонецФункции

Функция РавноСтруктуреИлиСоответствию(Знач ОжидаемоеЗначение) Экспорт
	
	ТипОжидаемогоЗначения = ТипЗнч(ОжидаемоеЗначение);
	Если Не (ТипОжидаемогоЗначения = Тип("Структура")
			Или ТипОжидаемогоЗначения = Тип("Соответствие")) Тогда
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ОжидаемоеЗначение, "ИМЕЕТ ТИП <Структура> или <Соответствие>.");
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
	
	// Используем функцию с детализацией
	РезультатСравнения = СтруктурыИлиСоответствияИдентичныСДетализацией(ПроверяемоеЗначение, ОжидаемоеЗначение, "");
	Если Не ЛогическоеВыражениеВерно(РезультатСравнения.Идентичны) Тогда
		ТипНазвание = ?(ТипОжидаемогоЗначения = Тип("Структура"), "структуре", "соответствию");
		СообщениеОшибки = СформироватьСообщениеОбОшибке(ПроверяемоеЗначение, СтрШаблон("РАВНО %1 (%2)%3%4", 
			ТипНазвание, ОжидаемоеЗначение, Символы.ПС, РезультатСравнения.ОписаниеОшибки));
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
	
	Возврат ЭтотОбъект;
КонецФункции

// Проверяет идентичность массивов с детализацией ошибок
// Параметры:
//   Массив1 - Массив - первый массив для сравнения
//   Массив2 - Массив - второй массив для сравнения
//   ПутьКЭлементу - Строка - путь к текущему элементу для отчета об ошибке
// Возвращаемое значение:
//   Структура - результат сравнения с полями Идентичны (Булево) и ОписаниеОшибки (Строка)
Функция МассивыИдентичныСДетализацией(Знач Массив1, Знач Массив2, Знач ПутьКЭлементу)
	
	Результат = Новый Структура("Идентичны, ОписаниеОшибки", Истина, "");
	
	// Проверяем типы
	Если ТипЗнч(Массив1) <> Тип("Массив") Или ТипЗнч(Массив2) <> Тип("Массив") Тогда
		Результат.Идентичны = Ложь;
		Результат.ОписаниеОшибки = СтрШаблон("Различие в %1: ожидался массив, но получен %2 и %3", 
			?(ПутьКЭлементу = "", "корне", ПутьКЭлементу), ТипЗнч(Массив1), ТипЗнч(Массив2));
		Возврат Результат;
	КонецЕсли;
	
	// Проверяем длину
	Если Массив1.Количество() <> Массив2.Количество() Тогда
		Результат.Идентичны = Ложь;
		Результат.ОписаниеОшибки = СтрШаблон("Различие в %1: разное количество элементов - ожидалось %2, получено %3", 
			?(ПутьКЭлементу = "", "корне", ПутьКЭлементу), Массив2.Количество(), Массив1.Количество());
		Возврат Результат;
	КонецЕсли;
	
	УчитыватьПорядокЗначений = Истина;
	Если ПараметрыСравненияМассивов.Свойство("УчитыватьПорядокЗначений") Тогда
		УчитыватьПорядокЗначений = ПараметрыСравненияМассивов.УчитыватьПорядокЗначений;
	КонецЕсли;
	
	Если УчитыватьПорядокЗначений Тогда
		// Проверяем все элементы по порядку
		Для Индекс = 0 По Массив1.Количество() - 1 Цикл
			НовыйПуть = ?(ПутьКЭлементу = "", СтрШаблон("[%1]", Индекс), СтрШаблон("%1[%2]", ПутьКЭлементу, Индекс));
			РезультатСравненияЭлемента = ЭлементыИдентичныСДетализацией(Массив1[Индекс], Массив2[Индекс], НовыйПуть);
			Если Не РезультатСравненияЭлемента.Идентичны Тогда
				Результат.Идентичны = Ложь;
				Результат.ОписаниеОшибки = РезультатСравненияЭлемента.ОписаниеОшибки;
				Возврат Результат;
			КонецЕсли;
		КонецЦикла;
	Иначе
		// Сравниваем элементы без учета порядка (упрощенная реализация для детализации)
		ОжидаемыеЭлементы = Новый Массив;
		Для Каждого Элемент Из Массив2 Цикл
			ОжидаемыеЭлементы.Добавить(Элемент);
		КонецЦикла;
		
		Для ИндексФакт = 0 По Массив1.Количество() - 1 Цикл
			ФактическийЭлемент = Массив1[ИндексФакт];
			НайденИндекс = -1;
			Для ИндексОжид = 0 По ОжидаемыеЭлементы.Количество() - 1 Цикл
				РезультатСравненияБазовый = ЭлементыИдентичныСДетализацией(ФактическийЭлемент, ОжидаемыеЭлементы[ИндексОжид], "");
				Если РезультатСравненияБазовый.Идентичны Тогда
					НайденИндекс = ИндексОжид;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			Если НайденИндекс = -1 Тогда
				Результат.Идентичны = Ложь;
				НовыйПуть = ?(ПутьКЭлементу = "", СтрШаблон("[%1]", ИндексФакт), СтрШаблон("%1[%2]", ПутьКЭлементу, ИндексФакт));
				Результат.ОписаниеОшибки = СтрШаблон("Элемент %1 со значением %2 не найден в ожидаемом массиве", 
					НовыйПуть, КраткоеПредставлениеЗначения(ФактическийЭлемент));
				Возврат Результат;
			Иначе
				ОжидаемыеЭлементы.Удалить(НайденИндекс);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Проверяет идентичность структур или соответствий с детализацией ошибок
// Параметры:
//   Объект1 - Структура, Соответствие - первый объект для сравнения
//   Объект2 - Структура, Соответствие - второй объект для сравнения
//   ПутьКЭлементу - Строка - путь к текущему элементу для отчета об ошибке
// Возвращаемое значение:
//   Структура - результат сравнения с полями Идентичны (Булево) и ОписаниеОшибки (Строка)
Функция СтруктурыИлиСоответствияИдентичныСДетализацией(Знач Объект1, Знач Объект2, Знач ПутьКЭлементу)
	
	Результат = Новый Структура("Идентичны, ОписаниеОшибки", Истина, "");
	
	ТипОбъекта1 = ТипЗнч(Объект1);
	ТипОбъекта2 = ТипЗнч(Объект2);
	
	// Проверяем типы
	Если ТипОбъекта1 <> ТипОбъекта2 Тогда
		Результат.Идентичны = Ложь;
		Результат.ОписаниеОшибки = СтрШаблон("Различие в %1: ожидался %2, получен %3", 
			?(ПутьКЭлементу = "", "корне", ПутьКЭлементу), ТипОбъекта2, ТипОбъекта1);
		Возврат Результат;
	КонецЕсли;
	
	Если Не (ТипОбъекта1 = Тип("Структура") Или ТипОбъекта1 = Тип("Соответствие")) Тогда
		Результат.Идентичны = Ложь;
		Результат.ОписаниеОшибки = СтрШаблон("Различие в %1: ожидались структура или соответствие, получен %2", 
			?(ПутьКЭлементу = "", "корне", ПутьКЭлементу), ТипОбъекта1);
		Возврат Результат;
	КонецЕсли;
	
	// Проверяем количество элементов
	Если Объект1.Количество() <> Объект2.Количество() Тогда
		Результат.Идентичны = Ложь;
		Результат.ОписаниеОшибки = СтрШаблон("Различие в %1: разное количество элементов - ожидалось %2, получено %3", 
			?(ПутьКЭлементу = "", "корне", ПутьКЭлементу), Объект2.Количество(), Объект1.Количество());
		Возврат Результат;
	КонецЕсли;
	
	// Проверяем все ключи и значения
	Для Каждого КлючЗначение Из Объект2 Цикл
		Ключ = КлючЗначение.Ключ;
		ОжидаемоеЗначение = КлючЗначение.Значение;
		
		Если Не СодержитКлюч(Объект1, Ключ) Тогда
			Результат.Идентичны = Ложь;
			НовыйПуть = ?(ПутьКЭлементу = "", СтрШаблон(".%1", Ключ), СтрШаблон("%1.%2", ПутьКЭлементу, Ключ));
			Результат.ОписаниеОшибки = СтрШаблон("Ключ %1 отсутствует в фактическом объекте", НовыйПуть);
			Возврат Результат;
		КонецЕсли;
		
		ФактическоеЗначение = ПолучитьЗначениеПоКлючу(Объект1, Ключ);
		НовыйПуть = ?(ПутьКЭлементу = "", СтрШаблон(".%1", Ключ), СтрШаблон("%1.%2", ПутьКЭлементу, Ключ));
		РезультатСравненияЗначения = ЭлементыИдентичныСДетализацией(ФактическоеЗначение, ОжидаемоеЗначение, НовыйПуть);
		Если Не РезультатСравненияЗначения.Идентичны Тогда
			Результат.Идентичны = Ложь;
			Результат.ОписаниеОшибки = РезультатСравненияЗначения.ОписаниеОшибки;
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	
	// Проверяем, что в фактическом объекте нет лишних ключей
	Для Каждого КлючЗначение Из Объект1 Цикл
		Ключ = КлючЗначение.Ключ;
		Если Не СодержитКлюч(Объект2, Ключ) Тогда
			Результат.Идентичны = Ложь;
			НовыйПуть = ?(ПутьКЭлементу = "", СтрШаблон(".%1", Ключ), СтрШаблон("%1.%2", ПутьКЭлементу, Ключ));
			Результат.ОписаниеОшибки = СтрШаблон("Лишний ключ %1 в фактическом объекте", НовыйПуть);
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Рекурсивно проверяет идентичность двух элементов с детализацией ошибок
// Параметры:
//   Элемент1 - Произвольный - первый элемент для сравнения
//   Элемент2 - Произвольный - второй элемент для сравнения
//   ПутьКЭлементу - Строка - путь к текущему элементу для отчета об ошибке
// Возвращаемое значение:
//   Структура - результат сравнения с полями Идентичны (Булево) и ОписаниеОшибки (Строка)
Функция ЭлементыИдентичныСДетализацией(Знач Элемент1, Знач Элемент2, Знач ПутьКЭлементу)
	
	Результат = Новый Структура("Идентичны, ОписаниеОшибки", Истина, "");
	
	ТипЭлемента1 = ТипЗнч(Элемент1);
	ТипЭлемента2 = ТипЗнч(Элемент2);
	
	// Сначала проверяем типы
	Если ТипЭлемента1 <> ТипЭлемента2 Тогда
		Результат.Идентичны = Ложь;
		Результат.ОписаниеОшибки = СтрШаблон("Различие в %1: ожидался %2, получен %3", 
			?(ПутьКЭлементу = "", "корне", ПутьКЭлементу), ТипЭлемента2, ТипЭлемента1);
		Возврат Результат;
	КонецЕсли;
	
	// Для структур и соответствий
	Если ТипЭлемента1 = Тип("Структура") Или ТипЭлемента1 = Тип("Соответствие") Тогда
		Возврат СтруктурыИлиСоответствияИдентичныСДетализацией(Элемент1, Элемент2, ПутьКЭлементу);
	КонецЕсли;
	
	// Для массивов
	Если ТипЭлемента1 = Тип("Массив") Тогда
		Возврат МассивыИдентичныСДетализацией(Элемент1, Элемент2, ПутьКЭлементу);
	КонецЕсли;
	
	// Для таблиц значений
	Если ТипЭлемента1 = Тип("ТаблицаЗначений") Тогда
		// Используем существующую логику сравнения таблиц без детализации
		Различия = РазличияТаблиц(Элемент1, Элемент2, Ложь);
		Если Различия.Количество() > 0 Тогда
			Результат.Идентичны = Ложь;
			Результат.ОписаниеОшибки = СтрШаблон("Различие в %1: таблицы значений не идентичны", 
				?(ПутьКЭлементу = "", "корне", ПутьКЭлементу));
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;
	
	// Для остальных типов - простое сравнение
	Если Элемент1 <> Элемент2 Тогда
		Результат.Идентичны = Ложь;
		Результат.ОписаниеОшибки = СтрШаблон("Различие в %1: ожидалось %2, получено %3", 
			?(ПутьКЭлементу = "", "корне", ПутьКЭлементу), 
			КраткоеПредставлениеЗначения(Элемент2), 
			КраткоеПредставлениеЗначения(Элемент1));
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

// Возвращает краткое представление значения для сообщений об ошибках
// Параметры:
//   Значение - Произвольный - значение для представления
// Возвращаемое значение:
//   Строка - краткое представление значения
Функция КраткоеПредставлениеЗначения(Знач Значение)
	
	ТипЗначения = ТипЗнч(Значение);
	
	Если Значение = Неопределено Тогда
		Возврат "Неопределено";
	ИначеЕсли ТипЗначения = Тип("Строка") Тогда
		Если СтрДлина(Значение) > 50 Тогда
			Возврат """" + Лев(Значение, 47) + "...""";
		Иначе
			Возврат """" + Значение + """";
		КонецЕсли;
	ИначеЕсли ТипЗначения = Тип("Число") Или ТипЗначения = Тип("Булево") Тогда
		Возврат Строка(Значение);
	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		Возврат Формат(Значение, "ДФ=dd.MM.yyyy ВФ=HH:mm:ss");
	ИначеЕсли ТипЗначения = Тип("Массив") Тогда
		Возврат СтрШаблон("Массив(%1)", Значение.Количество());
	ИначеЕсли ТипЗначения = Тип("Структура") Тогда
		Возврат СтрШаблон("Структура(%1)", Значение.Количество());
	ИначеЕсли ТипЗначения = Тип("Соответствие") Тогда
		Возврат СтрШаблон("Соответствие(%1)", Значение.Количество());
	ИначеЕсли ТипЗначения = Тип("ТаблицаЗначений") Тогда
		Возврат СтрШаблон("ТаблицаЗначений(%1х%2)", Значение.Количество(), Значение.Колонки.Количество());
	Иначе
		Возврат Строка(ТипЗначения);
	КонецЕсли;
	
КонецФункции

// Проверяет содержит ли объект указанный ключ
Функция СодержитКлюч(Знач Объект, Знач Ключ)
	
	ТипОбъекта = ТипЗнч(Объект);
	
	Если ТипОбъекта = Тип("Структура") Тогда
		Возврат Объект.Свойство(Ключ);
	ИначеЕсли ТипОбъекта = Тип("Соответствие") Тогда
		Возврат Объект.Получить(Ключ) <> Неопределено;
	Иначе
		ВызватьИсключение "Неподдерживаемый тип объекта для проверки ключа: " + ТипОбъекта;
	КонецЕсли;
	
КонецФункции

// Получает значение по ключу из объекта
Функция ПолучитьЗначениеПоКлючу(Знач Объект, Знач Ключ)
	
	ТипОбъекта = ТипЗнч(Объект);
	
	Если ТипОбъекта = Тип("Структура") Тогда
		Возврат Объект[Ключ];
	ИначеЕсли ТипОбъекта = Тип("Соответствие") Тогда
		Возврат Объект.Получить(Ключ);
	Иначе
		ВызватьИсключение "Неподдерживаемый тип объекта для получения значения по ключу: " + ТипОбъекта;
	КонецЕсли;
	
КонецФункции

// { Helpers
Функция ФорматДСО(Знач ДопСообщениеОшибки)
	Если ДопСообщениеОшибки = "" Тогда
		Возврат "";
	КонецЕсли;

	Возврат Символы.ПС + ДопСообщениеОшибки;
КонецФункции

Процедура ВызватьОшибкуПроверки(Знач СообщениеОшибки, Знач Причина = Неопределено)

	ТекстИсключения = "[Failed] " + СообщениеОшибки;
	Попытка
		ВызватьИсключение ТекстИсключения;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		СтекВызовов = ИнформацияОбОшибке.ПолучитьСтекВызовов();
		МассивТекстИсключения = Новый Массив;
		МассивТекстИсключения.Добавить(ТекстИсключения);
		МассивТекстИсключения.Добавить("Стек трейс:");

		Отступ = "";
		СимволОтступа = "  ";
		ПервыйКадр = Истина;
		Для Каждого КадрСтекаВызовов Из СтекВызовов Цикл
			// пропустим первый кадр стека, т.к. он ведет на служебный вызов исключения
			Если ПервыйКадр Тогда
				ПервыйКадр = Ложь;
				Продолжить;
			КонецЕсли;

			Отступ = Отступ + СимволОтступа;
						
			СтрокаСтекТрейса = СтрШаблон(
				"%1%2 / Метод %3 / Строка %4", 
				Отступ,
				КадрСтекаВызовов.ИмяМодуля,
				КадрСтекаВызовов.Метод,
				Формат(КадрСтекаВызовов.НомерСтроки, "ЧГ=") 
			);
			МассивТекстИсключения.Добавить(СтрокаСтекТрейса);
		КонецЦикла;
		ТекстИсключения = СтрСоединить(МассивТекстИсключения, Символы.ПС);

		Контекст = Новый ИсключениеОшибкаУтверждения();

		Если Число(Лев(Новый СистемнаяИнформация().Версия, 1)) >= 2 Тогда
			ВызватьИсключение Новый ИнформацияОбОшибке(ТекстИсключения, Контекст, Причина);
		Иначе
			ВызватьИсключение Новый ИнформацияОбОшибке(ТекстИсключения, Контекст);
		КонецЕсли;

	КонецПопытки;
КонецПроцедуры

Функция РазличияТаблиц(Знач ПроверяемоеЗначение, Знач ОжидаемоеЗначение, Знач СравнитьТолькоСтруктуру = Ложь)

	Различия = ПустаяТаблицаРазличийТаблиц();

	Для Каждого Различие Из РазличияТиповТаблиц(ПроверяемоеЗначение, ОжидаемоеЗначение) Цикл
		ЗаполнитьЗначенияСвойств(Различия.Добавить(), Различие);
	КонецЦикла;

	Если Различия.Количество() > 0 Тогда
		Возврат Различия;
	КонецЕсли;

	Для Каждого Различие Из РазличияКолонокТаблиц(ПроверяемоеЗначение, ОжидаемоеЗначение) Цикл
		ЗаполнитьЗначенияСвойств(Различия.Добавить(), Различие);
	КонецЦикла;

	Если СравнитьТолькоСтруктуру Тогда
		Возврат Различия;
	КонецЕсли;

	Для Каждого Различие Из РазличияСтрокТаблиц(ПроверяемоеЗначение, ОжидаемоеЗначение) Цикл
		ЗаполнитьЗначенияСвойств(Различия.Добавить(), Различие);
	КонецЦикла;

	Возврат Различия;
КонецФункции

Функция ПустаяТаблицаРазличийТаблиц()
	
	Различия = Новый ТаблицаЗначений;
	Различия.Колонки.Добавить("Строка");
	Различия.Колонки.Добавить("Колонка");
	Различия.Колонки.Добавить("Ожидание");
	Различия.Колонки.Добавить("Результат");

	Возврат Различия;
КонецФункции

Функция РазличиеТаблиц(Знач Строка = "", Знач Колонка = "", Знач Ожидание = "", Знач Результат = "")
	
	Различие = ПустаяТаблицаРазличийТаблиц().Добавить();
	Различие.Строка = Строка;
	Различие.Колонка = Колонка;
	Различие.Ожидание = Ожидание;
	Различие.Результат = Результат;
	
	Возврат Различие;
КонецФункции

Функция РазличияТиповТаблиц(Знач Таб1, Знач Таб2)
	
	Различия = ПустаяТаблицаРазличийТаблиц();

	Если Не ТипЗнч(Таб1) = Тип("ТаблицаЗначений") Тогда
		Различие = РазличиеТаблиц("ПРОВЕРЯЕМОЕ значение",
									"Тип значения",
									"ТаблицаЗначений",
									ТипЗнч(Таб1));
		ЗаполнитьЗначенияСвойств(Различия.Добавить(), Различие);
	КонецЕсли;
	Если Не ТипЗнч(Таб2) = Тип("ТаблицаЗначений") Тогда
		Различие = РазличиеТаблиц("ОЖИДАЕМОЕ значение",
									"Тип значения",
									"ТаблицаЗначений",
									ТипЗнч(Таб2));
		ЗаполнитьЗначенияСвойств(Различия.Добавить(), Различие);
	КонецЕсли;

	Возврат Различия;
КонецФункции

Функция РазличияКолонокТаблиц(Знач Таб1, Знач Таб2)

	Различия = ПустаяТаблицаРазличийТаблиц();

	Если Не Таб1.Колонки.Количество() = Таб2.Колонки.Количество() Тогда
		Различие = РазличиеТаблиц("ПРОВЕРЯЕМОЕ значение",
									"Количество КОЛОНОК",
									Таб2.Колонки.Количество(),
									Таб1.Колонки.Количество());
		ЗаполнитьЗначенияСвойств(Различия.Добавить(), Различие);
	КонецЕсли;
	
	Если Не ПараметрыСравненияТаблиц.УчитыватьИменаКолонок Тогда
		Возврат Различия;
	КонецЕсли;

	Для Кол = 0 По Таб1.Колонки.Количество() - 1 Цикл
		Колонки = КолонкиТаблицПоИндексу(Таб1, Таб2, Кол);
		Если Колонки[2] = Неопределено Или Не Колонки[1].Имя = Колонки[2].Имя Тогда
			Ожидание = ?(Колонки[2] = Неопределено, "<ОТСУТСТВУЕТ>", СтрШаблон("колонку ""%1""", Колонки[2].Имя));
			Результат = СтрШаблон("колонку ""%1""", Колонки[1].Имя);
			Различие = РазличиеТаблиц("ПРОВЕРЯЕМОЕ значение", "КОЛОНКИ", Ожидание, Результат);
			ЗаполнитьЗначенияСвойств(Различия.Добавить(), Различие);
		КонецЕсли;
	КонецЦикла;

	Возврат Различия;
КонецФункции

Функция КолонкиТаблицПоИндексу(Знач Таб1, Знач Таб2, Знач ИндексКолонки)
	
	КолонкаТаб1 = Таб1.Колонки[ИндексКолонки];
	Если ПоискКолонкиПоИмени() Тогда
		КолонкаТаб2 = Таб2.Колонки.Найти(КолонкаТаб1.Имя);
	Иначе
		КолонкаТаб2 = ?(ИндексКолонки < Таб2.Колонки.Количество(), Таб2.Колонки[ИндексКолонки], Неопределено);
	КонецЕсли;

	Колонки = Новый Массив;
	Колонки.Добавить("Для нумерации с 1");
	Колонки.Добавить(КолонкаТаб1);
	Колонки.Добавить(КолонкаТаб2);

	Возврат Колонки;
КонецФункции

Функция ПоискКолонкиПоИмени()
	Возврат ПараметрыСравненияТаблиц.УчитыватьИменаКолонок И Не ПараметрыСравненияТаблиц.УчитыватьПорядокКолонок;
КонецФункции

Функция РазличияСтрокТаблиц(Знач ПроверяемоеЗначение, Знач ОжидаемоеЗначение)

	Различия = ПустаяТаблицаРазличийТаблиц();

	Если Не ПроверяемоеЗначение.Количество() = ОжидаемоеЗначение.Количество() Тогда
		Различие = РазличиеТаблиц("ПРОВЕРЯЕМОЕ значение",
									"Количество СТРОК",
									ОжидаемоеЗначение.Количество(),
									ПроверяемоеЗначение.Количество());
		ЗаполнитьЗначенияСвойств(Различия.Добавить(), Различие);
	КонецЕсли;

	Если Различия.Количество() > 0 Тогда
		Возврат Различия;
	КонецЕсли;

	Если Не ПараметрыСравненияТаблиц.УчитыватьПорядокСтрок Тогда
		Таб1 = ПроверяемоеЗначение.Скопировать();
		Таб2 = ОжидаемоеЗначение.Скопировать();
		Таб1 = ОтсортироватьТаблицуПоВсемКолонкам(Таб1);
		Таб2 = ОтсортироватьТаблицуПоВсемКолонкам(Таб2);
	Иначе
		Таб1 = ПроверяемоеЗначение;
		Таб2 = ОжидаемоеЗначение;
	КонецЕсли;

	Для Стр = 0 По Таб1.Количество() - 1 Цикл
		Для Кол = 0 По Таб1.Колонки.Количество() - 1 Цикл
			Результат = Таб1[Стр][Кол];
			Колонки = КолонкиТаблицПоИндексу(Таб1, Таб2, Кол);
			Ожидание = ?(Колонки[2] = Неопределено, "<НЕТ КОЛОНКИ>", Таб2[Стр][Колонки[2]]);
			Если Не Ожидание = Результат Тогда
				Различие = РазличиеТаблиц(Стр, Кол, Ожидание, Результат);
				ЗаполнитьЗначенияСвойств(Различия.Добавить(), Различие);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

	Возврат Различия;
КонецФункции

Функция ОтсортироватьТаблицуПоВсемКолонкам(Знач ТЗ)
	
	ИменаКолонок = СтрСоединить(ИменаКолонок(ТЗ), ",");
	ТЗ.Сортировать(ИменаКолонок);

	Возврат ТЗ;
КонецФункции

Функция ИменаКолонок(Знач ТЗ)
	
	ИменаКолонок = Новый Массив;
	Для Каждого Колонка Из ТЗ.Колонки Цикл
		ИменаКолонок.Добавить(Колонка.Имя);
	КонецЦикла;

	Возврат ИменаКолонок;
КонецФункции

Функция ЛогическоеВыражениеВерно(Знач ЛогическоеВыражение)
	Результат = ФлагОтрицания <> ЛогическоеВыражение;
	ФлагОтрицанияДляСообщения = ФлагОтрицания;
	ФлагОтрицания = Ложь;

	Возврат Результат;
КонецФункции

Функция СформироватьСообщениеОбОшибке(Знач ПроверяемоеЗначение, Знач Ожидание)
	Возврат "Ожидали, что проверяемое значение (" + ПроверяемоеЗначение + ")" + ?(ФлагОтрицанияДляСообщения, " НЕ ", " ") + Ожидание + ФорматДСО(ДопСообщениеОшибки);
КонецФункции

Процедура ПроверитьЧтоМногострочнаяСтрокаСодержитПодстрокуБезУчетаНачальныхКонечныхПробеловВПодстроках(Знач Строка, Знач Подстрока, ДопСообщениеОшибки = "")
		СообщениеОшибки = "";
		Нашли = МногострочнаяСтрокаСодержитПодстрокуБезУчетаНачальныхКонечныхПробеловВПодстроках(Строка, Подстрока, СообщениеОшибки);
		Если Не Нашли Тогда
			ВызватьОшибкуПроверки( СтрШаблон("Ожидали, что в строке <
			|%1
			|>
			|найдем подстроку<
			|%2
			|>
			|А это не так.
			|Уточнение: %3.
			|%4", Строка, Подстрока, СообщениеОшибки, ДопСообщениеОшибки));
		КонецЕсли;
КонецПроцедуры

Функция МногострочнаяСтрокаСодержитПодстрокуБезУчетаНачальныхКонечныхПробеловВПодстроках(Знач Строка, Знач Подстрока, СообщениеОшибки = "")
	ПерваяСтрока = СокрЛП(СтрПолучитьСтроку(Подстрока, 1));
	НашлиПервуюСтроку = Ложь;
	Для Счетчик = 1 По СтрЧислоСтрок(Строка) Цикл
		ОчереднаяСтрока = СокрЛП(СтрПолучитьСтроку(Строка, Счетчик));
		НашлиПервуюСтроку = Найти(ОчереднаяСтрока, ПерваяСтрока) <> 0;
		Если НашлиПервуюСтроку Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если Не НашлиПервуюСтроку Тогда
		СообщениеОшибки = СтрШаблон("Не нашли первую же подстроку <%1>", ПерваяСтрока);
		Возврат Ложь;
	КонецЕсли;

	СчетчикЧтоИщем = 2;
	Для Счетчик = Счетчик+1 По СтрЧислоСтрок(Строка) Цикл
		ОчереднаяСтрока = СокрЛП(СтрПолучитьСтроку(Строка, Счетчик));
		ЧтоИщем = СокрЛП(СтрПолучитьСтроку(Подстрока, СчетчикЧтоИщем));
		Поз = Найти(ОчереднаяСтрока, ЧтоИщем);
		Если Поз = 0 Тогда
			СообщениеОшибки = СтрШаблон("Не нашли подстроку № %1 <%2>", СчетчикЧтоИщем, ЧтоИщем);
			Возврат Ложь;
		Иначе
			СчетчикЧтоИщем  = СчетчикЧтоИщем  + 1;
			Если СчетчикЧтоИщем > СтрЧислоСтрок(Подстрока) Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат СчетчикЧтоИщем > СтрЧислоСтрок(Подстрока);
КонецФункции

Функция ПредставлениеЗначения()
	Если ТипЗнч(ПроверяемоеЗначение) = Тип("Булево") Тогда
		Представление = Формат(ПроверяемоеЗначение, "БЛ=Ложь; БИ=Истина");
	Иначе
		Представление = "" + ПроверяемоеЗначение;
	КонецЕсли;
	Возврат Представление;
КонецФункции

Функция ЭтоЧитаемаяКоллекция(Тип)
	Возврат УтвержденияСлужебный.КоллекшоносЗагружен() 
		И Новый Рефлектор().МетодСуществует(Тип, "Содержит");
КонецФункции

Функция ЭтоЧитаемаяКарта(Тип)
	Возврат УтвержденияСлужебный.КоллекшоносЗагружен() 
		И Новый Рефлектор().МетодСуществует(Тип, "СодержитЗначение");
КонецФункции

Функция СодержитСтроку(ПроверяемоеЗначение, ИскомоеЗначение)

	Если СтрЧислоСтрок(ИскомоеЗначение) = 1 Тогда
		Результат = СтрНайти(ПроверяемоеЗначение, ИскомоеЗначение) > 0;
	Иначе
		ПроверитьЧтоМногострочнаяСтрокаСодержитПодстрокуБезУчетаНачальныхКонечныхПробеловВПодстроках(
			ПроверяемоеЗначение,
			ИскомоеЗначение, ФорматДСО(ДопСообщениеОшибки)
		);
		Результат = Истина;
	КонецЕсли;

	Возврат Результат;

КонецФункции

Функция СохранитьФлаги()

	Результат = Новый Структура(
		"ФлагОтрицания, ФлагОтрицанияДляСообщения",
		ФлагОтрицания,
		ФлагОтрицанияДляСообщения
	);

	ФлагОтрицания = Ложь;
	ФлагОтрицанияДляСообщения = Ложь;

	Возврат Результат;

КонецФункции

Процедура ВосстановитьФлаги(Флаги)

	ФлагОтрицания = Флаги.ФлагОтрицания;
	ФлагОтрицанияДляСообщения = Флаги.ФлагОтрицанияДляСообщения;

КонецПроцедуры

// } Helpers
